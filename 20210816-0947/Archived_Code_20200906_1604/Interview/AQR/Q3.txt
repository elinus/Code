You are given an array of integers arr and a starting number n. While iterating through the array from left to right, every time the current element is equal to n, the value of n is multiplied by two. For example, if arr = [2, 3, 4, 6] and n = 3, n will be doubled at positions 1 and 3 (0-based) - arr[1] = 3, which matches the initial value of n = 3, causing it to double to n = 6, which then matches arr[3] = 6.

You are allowed to reorder the array elements arbitrarily. Your task is to find the maximal possible value of n after rearranging the array entries and traversing it.

Example

For arr = [11, 8, 4, 1, 12, 2] and n = 2, the output should be exponentialGrowth(arr, n) = 16.

There are several possible rearrangements that will lead to the maximum possible value of n. One such example is [11, 2, 12, 4, 8, 1]. The initial number will be doubled at index 1 because arr[1] = 2. Afterwards, for similar reasons it is also doubled at indices 3 and 4, yielding a final value of n = 2 * 2 * 2 * 2 = 16.

example 1

For arr = [8, 7, 6, 5, 4, 3, 2, 1] and n = 3, the output should be exponentialGrowth(arr, n) = 12.

After reversing the initial array and traversing it, the initial number n = 3 will be doubled twice, for a final value of n = 12.

example 2

For arr = [24, 13, 12, 96, 25, 48] and n = 12, the output should be exponentialGrowth(arr, n) = 192.

One way to achieve the maximum value of n = 192 would be to arrange the array like this: [13, 12, 24, 48, 25, 96].

example 3

Input/Output

[execution time limit] 0.5 seconds (cpp)

[input] array.integer64 arr

An array of integers.

Guaranteed constraints:
1 ≤ arr.length ≤ 105,
0 ≤ arr[i] ≤ 1015.

[input] integer n

The initial value of n, which will double when equal to an element of arr.

Guaranteed constraints:
0 ≤ n ≤ 104.

[output] integer64

The maximum value of n when reordering arr optimally and completing the traversal described above.